 const renderPage = useCallback(async () => {
        if (!pdfDoc || !pageNumber || !canvasRef.current) return;
    
        const canvas = canvasRef.current;
        const context = canvas.getContext("2d");
    
        try {
            const page = await pdfDoc.getPage(pageNumber);
            const pageRotation = page.rotate; // Get the default rotation from the PDF metadata
            const combinedRotation = (rotation + pageRotation) % 360; // Combine default rotation with custom rotation
            const viewport = page.getViewport({ scale, rotation: combinedRotation });
    
            canvas.width = viewport.width * window.devicePixelRatio;
            canvas.height = viewport.height * window.devicePixelRatio;
            canvas.style.width = `${viewport.width}px`;
            canvas.style.height = `${viewport.height}px`;
    
            context.scale(window.devicePixelRatio, window.devicePixelRatio);
    
            if (renderTaskRef.current) {
                renderTaskRef.current.cancel();
            }
    
            renderTaskRef.current = page.render({
                canvasContext: context,
                viewport,
            });
    
            await renderTaskRef.current.promise;
        } catch (error) {
            if (error.name !== 'RenderingCancelledException') {
                console.error(`Error rendering page ${index + 1}:`, error);
                alert(`Error rendering page ${index + 1}: ${error.message}`);
            }
        }
    }, [pdfDoc, pageNumber, scale, rotation]);




const handleDownload = async () => {
    if (!pdfDoc) return;

    try {
        const pdfBytes = await fetch(pdfUrl).then((res) => res.arrayBuffer());
        const originalPdfDoc = await PDFDocument.load(pdfBytes);
        const newPdfDoc = await PDFDocument.create();

        for (const pageNumber of pageOrder) {
            const [copiedPage] = await newPdfDoc.copyPages(originalPdfDoc, [pageNumber - 1]);
            const pageRotation = (rotationPerPage[pageNumber - 1] || 0) + copiedPage.getRotation().angle;
            copiedPage.setRotation(degrees(pageRotation));
            newPdfDoc.addPage(copiedPage);
        }

        const newPdfBytes = await newPdfDoc.save();
        const blob = new Blob([newPdfBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "updated.pdf";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    } catch (error) {
        console.error("Error downloading PDF:", error);
        alert(`Error downloading PDF: ${error.message}`);
    }
};



useEffect(() => {
    if (pdfDoc) {
        (async () => {
            const page = await pdfDoc.getPage(1); // Test with the first page or any specific page
            console.log("Initial rotation of the page:", page.rotate);
        })();
    }
}, [pdfDoc]);

