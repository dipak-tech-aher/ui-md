import React, { useState, useEffect, useCallback, useRef } from 'react';
import * as pdfjsLib from 'pdfjs-dist/build/pdf';
import pdfjsWorker from 'pdfjs-dist/build/pdf.worker.entry';
import { DndProvider, useDrag, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import update from 'immutability-helper';
import { PDFDocument, degrees } from 'pdf-lib';
import { IconMaterial } from '@abyss/web/ui/IconMaterial';
import { Tooltip } from '@abyss/web/ui/Tooltip';
import { setPageOrder, setRotationPerPage } from '@src/Store';
pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker;
import { useDispatch, useSelector } from 'react-redux';

const ItemTypes = {
  PAGE: 'page',
};

const DraggablePage = ({
  isDraggable,
  pageNumber,
  index,
  movePage,
  pdfDoc,
  rotatePage,
  scale,
  isActive,
  pageRef,
  rotation,
}) => {
  const canvasRef = useRef(null);
  const renderTaskRef = useRef(null);
  const [{ isDragging }, drag] = useDrag({
    type: ItemTypes.PAGE,
    item: { index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });

  const [, drop] = useDrop({
    accept: ItemTypes.PAGE,
    hover: (draggedItem) => {
      if (draggedItem.index !== index && isDraggable) {
        movePage(draggedItem.index, index);
        draggedItem.index = index;
      }
    },
  });

  const renderPage = useCallback(async () => {
    if (!pdfDoc || !pageNumber || !canvasRef.current) return;

    const canvas = canvasRef.current;
    const context = canvas.getContext('2d');

    try {
      const page = await pdfDoc.getPage(pageNumber);
      const pageRotation = page.rotate;
      const combinedRotation = (rotation + pageRotation) % 360; // Combine default rotation with custom rotation
      const viewport = page.getViewport({ scale, rotation: combinedRotation });

      const pixelRatio = window.devicePixelRatio || 1;
      canvas.width = viewport.width * pixelRatio;
      canvas.height = viewport.height * pixelRatio;

      context.scale(window.devicePixelRatio, window.devicePixelRatio);

      if (renderTaskRef.current) {
        renderTaskRef.current.cancel();
      }

      renderTaskRef.current = page.render({
        canvasContext: context,
        viewport,
      });

      await renderTaskRef.current.promise;
    } catch (error) {
      if (error.name !== 'RenderingCancelledException') {
        console.error(`Error rendering page ${index + 1}:`, error);
        alert(`Error rendering page ${index + 1}: ${error.message}`);
      }
    }
  }, [pdfDoc, pageNumber, scale, rotation]);

  useEffect(() => {
    renderPage();
    return () => {
      if (renderTaskRef.current) {
        renderTaskRef.current.cancel();
      }
    };
  }, [renderPage]);

  const handleRotateClockwise = () => {
    const newRotation = (rotation + 90) % 360;
    rotatePage(index, newRotation);
  };

  const handleRotateAnticlockwise = () => {
    const newRotation = (rotation - 90 + 360) % 360;
    rotatePage(index, newRotation);
  };

  return (
    <>
      <div
        ref={(node) => {
          drag(drop(node));
          pageRef(node);
        }}
        className={`page-container ${isActive ? 'active' : ''} ${
          isDraggable ? 'cursor-move' : ''
        }`}
        style={{ opacity: isDragging ? 0.5 : 1 }}
      >
        <canvas ref={canvasRef} />
      </div>
      <div className="flex fd-rev gap-5 p-r bottom-17 jc-center">
        <Tooltip content="Rotate Clockwise">
          <span aria-label="Tooltip information">
            <IconMaterial
              className="cursor-pointer fill-color-black"
              icon="rotate_right"
              onClick={handleRotateClockwise}
            />
          </span>
        </Tooltip>
        <span className="page-number">{pageNumber}</span>
        <Tooltip content="Rotate Anti Clockwise">
          <span aria-label="Tooltip information">
            <IconMaterial
              className="cursor-pointer fill-color-black"
              icon="rotate_left"
              onClick={handleRotateAnticlockwise}
            />
          </span>
        </Tooltip>
      </div>
    </>
  );
};

const PDFViewerNew = ({ pdfFile }) => {
  const claimPreviewData = useSelector((state) => state?.claimsPreview);
  const pageOrder = claimPreviewData?.pageOrder?.pageOrder || [];
  const rotationPerPage = claimPreviewData?.rotationPerPage?.rotationPerPage || {};
  const [error, setError] = useState(null);
  const [pdfUrl, setPdfUrl] = useState(pdfFile);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [totalPages, setTotalPages] = useState(0);
  const [scale, setScale] = useState(1);
  const [currentPage, setCurrentPage] = useState(1);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const pageRefs = useRef([]);
  const fileInputRef = useRef(null);
  const dispatch = useDispatch();

  const loadPdfDocument = async (pdfFileOrUrl) => {
    try {
      let pdf;
      if (typeof pdfFileOrUrl === 'string') {
        pdf = await pdfjsLib.getDocument(pdfFileOrUrl).promise;
      } else {
        const arrayBuffer = await pdfFileOrUrl.arrayBuffer();
        pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      }
      setPdfDoc(pdf);
      setTotalPages(pdf.numPages);
      dispatch(
        setPageOrder({
          pageOrder: [...Array(pdf.numPages).keys()].map((i) => i + 1),
        })
      );
      setCurrentPage(1);
    } catch (error) {
      console.error('Error loading PDF:', error);
      setError(`Error loading PDF: ${error.message}`);
    }
  };

  useEffect(() => {
    if (pdfUrl) {
      loadPdfDocument(pdfUrl);
    }
  }, [pdfUrl]);

  const movePage = (fromIndex, toIndex) => {
    const updatedOrder = update(pageOrder, {
      $splice: [
        [fromIndex, 1],
        [toIndex, 0, pageOrder[fromIndex]],
      ],
    });
    dispatch(
      setPageOrder({
        pageOrder: updatedOrder,
      })
    );
  };

  const rotatePage = (index, newRotation) => {
    dispatch(
      setRotationPerPage({
        rotationPerPage: {
          ...rotationPerPage,
          [index]: newRotation,
        },
      })
    );
  };

  const handleZoomIn = () => {
    setScale((prevScale) => Math.min(prevScale + 0.1, 4));
  };

  const handleZoomOut = () => {
    setScale((prevScale) => Math.max(prevScale - 0.1, 0.5));
  };

  const toggleDrawer = () => setDrawerOpen((prev) => !prev);

  const handleDownload = async () => {
    if (!pdfDoc) return;

    try {
      const pdfBytes = await fetch(pdfUrl).then((res) => res.arrayBuffer());
      const originalPdfDoc = await PDFDocument.load(pdfBytes);
      const newPdfDoc = await PDFDocument.create();

      for (const pageNumber of pageOrder) {
        const [copiedPage] = await newPdfDoc.copyPages(originalPdfDoc, [
          pageNumber - 1,
        ]);
        const pageRotation =
          (rotationPerPage[pageNumber - 1] || 0) + copiedPage.getRotation().angle;
        copiedPage.setRotation(degrees(pageRotation));
        newPdfDoc.addPage(copiedPage);
      }

      const newPdfBytes = await newPdfDoc.save();
      const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');

      link.href = url;
      link.download = 'updated.pdf';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error downloading PDF:', error);
      alert(`Error downloading PDF: ${error.message}`);
    }
  };

  const handlePrint = async () => {
    if (!pdfDoc) return;

    try {
      const pdfBytes = await fetch(pdfUrl).then((res) => res.arrayBuffer());
      const originalPdfDoc = await PDFDocument.load(pdfBytes);
      const newPdfDoc = await PDFDocument.create();

      for (const pageNumber of pageOrder) {
        const [copiedPage] = await newPdfDoc.copyPages(originalPdfDoc, [
          pageNumber - 1,
        ]);
        const pageRotation =
          (rotationPerPage[pageNumber - 1] || 0) + copiedPage.getRotation().angle;
        copiedPage.setRotation(degrees(pageRotation));
        newPdfDoc.addPage(copiedPage);
      }

      const newPdfBytes = await newPdfDoc.save();
      const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);

      const printWindow = window.open(url, '_blank');
      printWindow.addEventListener('load', () => {
        printWindow.print();
        printWindow.onafterprint = () => {
          printWindow.close();
          URL.revokeObjectURL(url);
        };
      });
    } catch (error) {
      console.error('Error printing PDF:', error);
      alert(`Error printing PDF: ${error.message}`);
    }
  };

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="pdf-viewer">
        {error && <div className="error">{error}</div>}
        <div className="toolbar">
          <button onClick={handleZoomIn}>Zoom In</button>
          <button onClick={handleZoomOut}>Zoom Out</button>
          <button onClick={toggleDrawer}>Toggle Drawer</button>
          <button onClick={handleDownload}>Download PDF</button>
          <button onClick={handlePrint}>Print PDF</button>
        </div>
        <div className="pdf-pages">
          {pageOrder.map((pageNumber, index) => {
            const rotation = rotationPerPage[pageNumber - 1] || 0;
            return (
              <DraggablePage
                key={pageNumber}
                isDraggable={true}
                pageNumber={pageNumber}
                index={index}
                movePage={movePage}
                pdfDoc={pdfDoc}
                rotatePage={rotatePage}
                scale={scale}
                isActive={currentPage === pageNumber}
                pageRef={(node) => (pageRefs.current[index] = node)}
                rotation={rotation}
              />
            );
          })}
        </div>
      </div>
    </DndProvider>
  );
};

export default PDFViewerNew;
